Dependeny declarations
======================

All dependencies are declared in lines as "before" - "after" examples:

a b
b c

means "a" must become before "b" and "b" must become before "c".

Besides actual dependency items like "a" and "b" there are so-called
"dependency groups" represented by virtual group markers.

For each dependency item "a" there is also a group to which "a" belongs,
identified by the group markers "^a" and "a$".

Whenever a dependency "a" exists, the system will automatically synthesize
the following dependency declarations:

^a a
a a$

In other words, "^a" precedes "a" and "a$" follows "a".

Groups represent optional dependencies. When writing

a b

then "a" *needs* to be started before "b". However, when writing

a$ b

then just "the group belonging to a" must precede "b", not necessarily "a"
itself: When a dependency "a" does not actually exist, it is still possible
to refer to its group markers. Markers, like all dependencies, spring into
existend by merely mentioning them as dependencies.

Other than real dependencies, group markers will never actually be tried to
run, so there is no problem if the dependency after which the group is named
does not exist.

In order to avoid that dependency declarations for some item need to refer
to the name of the item explicitly, there are a few shortcuts.

When some item "a" is queried for its dependencies, "@" is an alias for "a"
itself, while "^@" is an alias for "^a" and "@$" is an alias for "a$".

One problem arises when representing runlevels this way, because the same
item could be part of many runlevels, yet all dependencies must declare a
struct ordering without any loops.

In order to solve this problem, automatic aliases can be generated for every
dependency.

For instance, if a dependency "sshd" needs to be a member of both
"runlevel_3" and "runlevel_5", it can define the following dependencies:

^runlevel_1 @[1]
@[1] runlevel_1$
^runlevel_5 @[5]
@[5] runlevel_5$

Here, the expressions "@[1]" and "@[5]" generate aliases for "@" which are
unique among all aliases generated by all dependencies, but the arguments
between the brackets need to be only locally unique within the item
declaring the dependency.

Actually, the locally unique indices between brackets do not need to be
integer numbers like in this example; they can be arbitrary strings not
containing whitespace or the character "]".

The bracket syntax does not need to be combined with a "@" shortcut, the
bracketed references can be used together with normal item names
like "a[1]" or "^a[1]" or "a[1]$" as well.


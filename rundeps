#! /bin/sh
exit_version() {
	wr -s <<- . && exit
	$APP version 15.214

	(c) 2015 by Guenther Brunthaler.
	This script is free software.
	Distribution is permitted under the terms of the GPLv3.
.
}
APP=${0##*/}

wr() {
	test -z "$*" && set -- -c
	fmt -w "$LINEWIDTH" "$@"
}
LINEWIDTH=; test -t 0 && LINEWIDTH=`tput cols 2> /dev/null` || LINEWIDTH=
: ${LINEWIDTH:=70}

exit_help() {
	wr <<- .
	$APP - run executables from a directory in the correct order

	The executables, which can also be scripts, will first be queried in
	random order to state their dependencies. Then they will be run in the
	correct order, or in parallel where no specific order is required.
	
	Usage: $APP
	    [ options ... ] [ <pass-through-arguments> ... ]
	    
	where:
	
	<pass-through-arguments>:
	  The arguments to pass to all the executables once they are run. For instance,
	  if the executables happen to be /etc/init.d-style scripts, "start" might be
	  specified as argument.

	Supported options:

	-n:
	   Instead of actually running the executable, just print the order in
	   which they would be started. Where order matters, executables will
	   be printed on different lines in order of starting time.
	   Executables which can be run in parallel are printed on the same
	   line. Note that although the executables will not be run "normally"
	   with the <pass-through-arguments>, they will still be run for for
	   printing their dependencies, because otherwise $APP has no
	   information to work with.
	-q <string>:
	   A string which will be used as the only argument when running the
	   executables which shall make them state their dependendies instead
	   of doing what they are normally supposed to do. Default is "deps".
	-d) <directory>:
	   By default, $APP reads the list of executables to query for
	   dependencies from standard input, such as the output of "find". For
	   simple cases, however, $APP can run "find" itself using the "-d"
	   option. It will recursively scan <directory> for all executables
	   not containing any of the following characters in their basenames:
	   ".", ",", "~", "#". Basenames starting with "^", ending with "$" or
	   identical to "@" will also be ignored. This should protect against
	   most backup, distribution-autogenerated files or version-control
	   archives such as "file.bak", "file~", "file.dist", "file.orig",
	   "file.rej", ".cfg_file", "file,v" etc. Executables can also simply
	   be "disabled" from processing by renaming them to, say,
	   "file.disabled". Also, directory basenames starting with a "." will
	   be excluded from the recursive search. This avoids directories such
	   as ".git", ".bzr", ".hg" etc.
	-D "<before> <after>":
	   This allows to inject additional dependencies from the command
	   line. The option may be specified as often as desired and each
	   option argument has the same contents as any of the dependency
	   lines printed by the executables, except that the macros "^@", "@"
	   and "@\$" are not available.
	-r:
	   Reverse the calculated dependency order. This can be used, for
	   instance, to let scripts with a "stop" argument run in the reverse
	   order they were run with the "start" argument, assuming that the
	   scripts report only the dependencies for startup.
	-h:
	    Show this usage help.
	-V:
	    Show version information for $APP.

	$APP scans <directory> recursively for executables files, or reads a
	list of path names of such files from standard input if "-" is
	specified as a directory. (In order to specify a director actually
	named "-", use "./-" instead.)
	
	There are some restrictions on the basename of the executables: They
	must not start with "^", must not end with "\$", and must not be named
	"@" and contain no whitespace. Such files will silently be removed
	from the list of executables to be processed. The same is true for
	files which do not exist, or do not have effective executable
	permissions for the current user.
	
	Then, $APP runs every executable with the query string (see option -q)
	as its only argument, and the executables are expected to print their
	dependency requirements to standard output, and then immediatey
	terminate successfully.
	
	It is perfectly fine if an executable prints nothing when run that
	way; in this case it has no special dependencies.
	
	After $APP has collected all dependency declarations that way, it
	calculates the correct order, and then runs the executables in that
	order.
	
	The format in which the dependencies shall be printed by the
	executables when queried by $APP is as follows:
	
	The dependencies need to be specified in multiple lines; every
	dependency specification goes into its own line. The order of lines is
	irrelevant. No empty lines or comments are allowed.
	
	Within each dependency line, a before-after dependency must be
	specified as two strings separated by a single ASCII space as
	separator. This states that the item represented by the first string
	must be started before the item represented by the second string.

	The strings can either be the basenames of the executables which shall
	be run, or they can be arbitrary other strings which then represent
	synthetic "helper" items which will not be attempted to be run as
	executables once the correct order for all items has been determined.
	
	There are three macros which an executable may use in its dependency
	output: "@" will be expanded to the name of the executable itself,
	"^@" to its name with "^" prepended, and "@\$" to its name with "\$"
	appended.
	
	So, for an executable "foo", "@" expands to "foo", "^@" expands to
	"^foo" and "@$" expands to "foo\$"
	
	Also, for every executable actually queried for its dependencies, the
	following two lines will automatically be appended to its output:
.
	wr -s <<- .
	^@ @
	@ @$

.
	wr <<- .
	
	In addition, for every string "^SOMETHING" or "SOMETHING$" found in
	any dependency line (no matter ), a dependency "^SOMETHING SOMETHING$"
	will be synthesized no matter whether "SOMETHING" is an existing
	executable or not.
	
	This is intended to automatically create a time-order group for every
	executable, which contains the executable itself if it exists, but
	will also be present as an empty group if the executable does not
	exist.
	
	These groups can be used for specifying optional dependencies which
	are only required if the executable actually exists.
	
	They can also be used to implement "belongs to"-semantics such as the
	"\$network" virtual service of sysvinit scripts.
	
	One big advantage of the resulting dependency system is that any
	dependency can be specified in any file, because dependency
	declarations are (after macro expansion) self-contained and work
	independently of the executables which specified them.
	
	It is therefore never necessary to edit a foreign script in order to
	add missing dependencies; this can always be done from one's own
	scripts instead.
.
	exit_version
}

print() {
	printf '%s\n' "$*"
}

die() {
	print "$*" >& 2
	false || exit
}

set -e
cleanup() {
	local rc=$?
	test -n "$pid0" && wait $pid0 || :
	$redir0 && exec <& -
	$redir5 && exec 5>& -
	test -n "$TD" && rm -r -- "$TD"
	test $rc = 0 || echo "Failed!" >& 2
}

term() {
	test -n "$pid0" && kill $pid0 2> /dev/null || :
}

TD=
redir5=false
redir0=false
pid0=
trap cleanup 0
trap term HUP INT QUIT ABRT TERM

TD=`mktemp -d "${TMPDIR:-/tmp}/$APP-XXXXXXXXXX"`
deps=$TD/deps
exec 5> "$deps"; redir5=true
dry_run=false
query=deps
scandir=
reverse=false
while getopts nq:d:D:rVh OPT
do
	case $OPT in
		n) dry_run=true;;
		q) query=$OPTARG;;
		d) scandir=$OPTARG;;
		D) print "$OPTARG" >& 5;;
		r) reverse=true;;
		V) exit_version;;
		h) exit_help;;
		*) false || exit
	esac
done
shift `expr $OPTIND - 1 || :`
if test -n "$scandir"
then
	test -d "$scandir"
	f=$TD/find
	mkfifo "$f"
	find "$scandir" -name '.*' ! -name . -prune -o -type f "(" \
		-perm -u=x -o -perm -g=x -o -perm -o=x \
	")" -print \
	| grep -vE '.*/[^/]*[#.,~][^/]*$|\^^|^@$|$\$' > "$f" & pid0=$!
	exec < "$f"; redir0=true
fi
while IFS= read -r exe
do
	case $exe in
		"^"* | *"$" | "@") continue
	esac
	expr x"$exe" : x".*[[:space:]]" > /dev/null && continue
	test ! -e "$exe" || test ! -x "$exe" && continue
	echo $exe
done
